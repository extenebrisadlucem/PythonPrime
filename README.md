# PythonPrime
Converting hpprime menus to python

# Introduction
Suite à mon boulot le resenssement des fonction de la calculatrice HP Prime : https://on7aur.wordpress.com/2025/01/25/liste-des-fonctions-de-la-hpprime/
J'ai eu l'idée de convertir tout ça en python...

Ce travail n'est pas tout à fait exacte . J'ai travaillé avec une installation locale du moteur deepseek 14b - qui consomme 130Watts sur mon serveur lorsqu'il réfléchis...
Toute aide sera la bienvenue pour corriger les éventuels problèmes.

Ma première idée était de tester toutes les snippets dans des prompts jupyter, mais vu la quantité de snippets, c'est un boulot fastidieux . J'ai tenté quelques prompts, mais comment s'assurer que l'IA sera honnête en êtant juge et partie ayant sa somme de connaissances. Recruter une IA sur le net à raison de 10 prompts de maximum 10 lignes par heures ?

Du coup, en attendant que je trouve un moyen efficace de valider tout ça, je poste ici.

=> <sub>Je ne donne donc aucune garantie sur le résultat de ces snippets.</sub> 

# Matching entre la prime et les fonctions Python
## Menu cas
| Menu | Fonction | Exemple | Code Python | Résultat | Description |
|------|----------|---------|-------------|----------|-------------|
| Algebra | Simplifier | `simplify(-3*sqrt(2)+3)` | `from sympy import sqrt, simplify`<br>`simplify(-3*sqrt(2)+3)` | `-3*sqrt(2)+3`            | Simplifie une expression mathématique |
| Algebra | Regrouper  | `collect(x^3-2*x^2+1)`   | `from sympy import factor`<br>`factor(x**3 - 2*x**2 +1)`| `(x-1)*(x²-x-1)`         | Factoriser un polynôme sur les entiers|
| Algebra | Développer |  `expand((x+2)(x-3))`     | `from sympy import expand`<br>`print(expand((x+2)*(x-3)))`| `x²-x-6`                  | Développe un produit |
| Algebra | Factoriser |  `factor(x²+2x+1)`        | `from sympy import factor`<br>`print(factor(x**2 + 2*x +1))`| `(x+1)²`                  | Décompose une expression en ses facteurs |
| Algebra | Factoriser Complexe | `factor(x²+1)`   | `from sympy import factor, I`<br>`factor(x**2 + 1, extension=True)`| `(x - I)*(x + I)`| Factoriser un polynôme sur les nombres complexes |
| Algebra |  Substituer  | `subst(a^2+1,a=3)` | `from sympy import Symbol, subs`<br>`a = Symbol('a')`<br>`print(subs(a,3,a**2 +1))` | `10` |  Remplace  une variable par une valeur dans une expression |
| Algebra |  Fraction Partielle  | `partfrac((x^5+x^3)/(x^4-1))` | `from sympy import apart`<br>`print(apart((x**5 + x**3)/(x**4 -1)))` | `x+1/4(x-1)+1/4(x+1)+x/(2(x²+1))` |  Décompose  une fraction rationnelle en éléments simples |
| Algebra |  Extraire Numérateur  | `numer(2/3+x/2)` | `from sympy import Fraction`<br>`print(Fraction(2/3 + x/2).numerator)`| `2*x+4` |  Extrait le numérateur  d'une fraction après simplification |
| Algebra |  Extraire Dénominateur  | `denom(10/12)` | `from sympy import Fraction`<br>`print(Fraction(10/12).denominator)`| `6` |  Extrait le dénominateur  d'une fraction après simplification |
| Algebra |  Extraire Côté Gauche  | `left(x^2-1=2*x+3)` | `s = 'x**2 -1 = 2*x +3'`<br>`print(s.split('=')[0].replace(' ', ''))`| `x^2-1` |  Extrait le membre de gauche  d'une équation |
| Algebra |  Extraire Côté Droit  | `right(x^2-1=2*x+3)` | `s = 'x**2 -1 = 2*x +3'`<br>`print(s.split('=')[1].replace(' ', ''))`| `2*x+3` |  Extrait le membre de droite  d'une équation |
| Calculus  | Dérivée        | `diff(x²,x)`        | `from sympy import diff`<br>`diff(x**2, x)`   | `2x`              | Calcule la dérivée d'une fonction         |
| Calculus  | Intégrale      | `integrate(x²,x)`   | `from sympy import integrate`<br>`integrate(x**2, x)` | `x³/3`           | Calcule l'intégrale d'une fonction          |
| Calculus  | Limite        | `limit(sin(x)/x,x,0)| `from sympy import limit`<br>`limit(sin(x)/x, x, 0)` | `1`               | Calcule la limite d'une fonction            |
| Calculus  | Série         | `series(tan(x))`    | `from sympy import series`<br>`series(tan(x))`  | `x+1/3*x**3+2/15*x**5+x**6*order_size(x)` | Développement limité d'une expression        |
| Calculus  | Somme          | `sum(k^2,k,1,3)`    | `from sympy import summation`<br>`i= symbols('i', integer=True)`<br>`summation(i**2, (i, 1, 3))` | `14`             | Calcule la somme d'une expression pour une variable allant d'une valeur de début à une valeur de fin |
| Calculus  | Différentiel - Rotationnel | `curl([x*y,x*z,y*z],[x,y,z])` | `from sympy import curl`<br>`curl([x*y, x*z, y*z], [x, y, z])` | `[z, -y, -x]`   | Calcule le rotationnel d'un champ vectoriel |
| Calculus  | Différentiel - Divergence    | `divergence([x^2,y^2,z^2],[x,y,z])` | `from sympy import divergence`<br>`divergence([x**2, y**2, z**2], [x, y, z])` | `2*x + 2*y + 2*z` | Calcule la divergence d'un champ vectoriel    |
| Calculus  | Différentiel - Gradient      | `grad(x²*y+z,[x,y,z])`         | `from sympy import gradient`<br>`gradient(x**2*y + z, [x, y, z])`        | `[2*x*y, x**2, 1]`| Calcule le gradient d'une fonction scalaire   |
| Calculus  | Différentiel - Hessienne     | `hessian(x²*y+z,[x,y,z])`       | `from sympy import hessian`<br>`hessian(x**2*y + z, [x, y, z])`          | `[[2*y, 2*x, 0], [2*x, 0, 0], [0, 0, 0]]`   | Calcule la matrice Hessienne d'une fonction scalaire |
| Calculus | Intégral - Par parties v | `ibpdv(ln(x),x)` | `from sympy import ln, symbols, Integral`<br>`x = symbols('x')`<br>`Integral(ln(x), x).doit()  # Utilise la méthode do_it pour calculer l'intégrale par parties` | `x*ln(x)-x` | Calcule une primitive par intégration par parties en choisissant v' |
| Calculus | Intégral - Par parties u | `ibpu(x*exp(x),x)` | `from sympy import exp, symbols, Integral`<br>`x = symbols('x')`<br>`Integral(exp(x)*x, x).doit()  # Utilise la méthode do_it pour calculer l'intégrale par parties` | `x*exp(x)-exp(x)` | Calcule une primitive par intégration par parties en choisissant u |
| Calculus | Intégral - f(b)-f(a) | `preval(x^2-2,2,3)` | `from sympy import symbols, Integral`<br>`x = symbols('x')`<br>`Integral(x**2 - 2, x).evaluated.subs(x, [2, 3]).doit()` | `5` | Calcule la différence de l'intégrale entre b et a |
| Calculus | Limites - Somme de Riemann | `sum_riemann(k^2/n^3,[n,k])` | ``from sympy import symbols, summation`<br>`n, k = symbols('n k')`<br>`summation(k**2 / n**3, (k, 1, n))` | `1/3` | Calcule la somme de Riemann pour l'approximation d'une intégrale |
| Calculus | Limites - Taylor | `taylor(sin(x),x=1,2)` | `from sympy import sin, symbols, series`<br>`x = symbols('x')`<br>`sin(x).series(x, 1, 5).removeO().as_expr()` | `sin(1) + (x - 1)*cos(1) - (x - 1)**2*sin(1)/2` | Calcule le développement de Taylor en utilisant la méthode series |
| Calculus | Limites - Quotient de Taylor | `divpc(x^4+x+2,x^2+1,5)` | `from sympy import symbols, div`<br>`x = symbols('x')`<br>`div(x**4 + x + 2, x**2 + 1).truncate(5)` | Résultat du quotient de Taylor tronqué à l'ordre 5 -> `x^5+3*x^4-x^3-2*x^2+x+2` |  Calcule le polynôme de Taylor  du quotient de deux polynômes |
| Calculus | Transformation - Laplace | `laplace(exp(x))` | `from sympy import exp, symbols, laplace_transform`<br>`x = symbols('x')`<br>`laplace_transform(exp(x), x, s)` | `1/(s - 1)` | Calcule la transformée de Laplace |
| Calculus | Transformation - Laplace inversé | `invlaplace(1/(x^2+1))` | `from sympy import symbols, inverse_laplace_transform`<br>`x = symbols('x')`<br>`inverse_laplace_transform(1 / (s**2 + 1), s, t)` | `sin(t)` | Calcule la transformée de Laplace inverse |
| Calculus | Transformation - Fourier rapide | `fft()` | `from sympy import fft`<br>`# Implementation de base de FFT en Sympy` |`[2., -1-i, 0., -1+i]`| Résultat de la transformation de Fourier rapide |
| Calculus | Transformation - Fourier rapide inverse | `ifft([2,-1-i,0,-1+i])` | `from sympy import ifft`<br>`# Implementation de base de IFFT en Sympy` |`[0., 1., 1., 0.]`| Résultat de la transformation inverse de Fourier |
| Solve | Résoudre équation | `solve(x²=4,x)` | `from sympy import symbols, Eq, solve`<br>`x = symbols('x')`<br>`solve(Eq(x**2, 4), x)` | `{-2, 2}` | Résout une équation |
| Solve | Zéros | `zeros(x^2-4,x)` | `from sympy import symbols, solve`<br>`x = symbols('x')`<br>`solve(x**2 - 4, x)` | `[-2, 2]` | Trouve les zéros réels d'une expression |
| Solve | Résolution Complexe | `cSolve(x^2+1=0,x)` | `from sympy import symbols, Eq, solve`<br>`x = symbols('x')`<br>`solve(Eq(x**2 + 1, 0), x)` | `[-i, i]` | Résout une équation dans le domaine complexe |
| Solve | Zéros complexe | `cZeros(x^4-1)` | `from sympy import symbols, solve`<br>`x = symbols('x')`<br>`solve(x**4 - 1, x)` | `[1, -1, -i, i]` | Trouve les zéros complexes d'une expression |
| Solve | Résolution numérique | `fSolve(cos(x)=x,x,-1..1)` | `from sympy import cos, symbols, nsolve`<br>`x = symbols('x')`<br>`nsolve(Eq(cos(x), x), x, 0)` | `[0.739085133215]` | Trouve une solution numérique approchée d'une équation |
| Solve | Équation différentielle | `deSolve(y''+y=0,y)` | `from sympy import symbols, Function, dsolve`<br>`x = symbols('x')`<br>`y = Function('y')(x)`<br>`dsolve(y.diff(x).diff(x) + y, y)` | `G_0*cos(x) + G_1*sin(x)` | Résout une équation différentielle |
| Solve | Résolution EDO | `odesolve(f(t,y),[t,y],[t0,y0],t1)` | `from scipy.integrate import odeint`<br>`def f(t, y):`<br>`return some_function(t, y)`<br>`# Conditions initiales et intervalle de temps`<br>`y0 = [some_initial_condition]`<br>`t = np.linspace(t0, t1)`<br>`solution = odeint(f, y0, t)` | `[...]` | Résout numériquement une équation différentielle ordinaire avec conditions initiales (le résultat est une solution approximative) |
| Solve | Système linéaire | `linsolve([x+y=5,x-y=1],[x,y])` | `from sympy import symbols, Eq, linsolve`<br>`x, y = symbols('x y')`<br>`equations = [`<br>`    Eq(x + y, 5),`<br>`    Eq(x - y, 1)`<br>`]`<br>`linsolve(equations, (x, y))` | `[3, 2]` | Résout un système d'équations |
| Rewrite |  lncollect  | `lncollect(ln(x)+2*ln(y))` | `from sympy import lncollect`<br>`i= symbols('i', integer=True)`<br>`lncollect(i**2, (i, 1, 3))` |`ln(x*y^2)` |  Regroupe les termes  d'une expression contenant des logarithmes |
| Rewrite |  powexpand  | `powexpand(2^(x+y))`       | `from sympy import powexpand`<br>`i= symbols('i', integer=True)`<br>`powexpand(2^(x+y))` |`(2^x)*(2^y)` |  Réécrit  une expression contenant une puissance sous la forme d'un produit de puissances |
| Rewrite |  texpand  | `texpand(sin(2*x)+exp(x+y))` | `from sympy import texpand`<br>`i= symbols('i', integer=True)`<br>`texpand(sin(2*x)+exp(x+y))` |`exp(x)*exp(y)+2*cos(x)*sin(x)` |  Développe  une expression transcendante ou trigonométrique |
| Rewrite |  Exp et Ln - $e^{y*ln(x)}\rightarrow x^y$  | `exp2pow(exp(3*ln(x)))` | `from sympy import exp2pow`<br>`i= symbols('i', integer=True)`<br>`exp2pow(exp(3*ln(x)))` | `x^3` |  Transforme une expression  de la forme $e^{n*ln(x)}$ en une puissance de x |
| Rewrite |  Exp et Ln - $x^y\rightarrow e^{y*ln(x)}$  | `pow2exp(a^b)` | `from sympy import pow2exp`<br>`i= symbols('i', integer=True)`<br>`pow2exp(a^b)` | `exp(b*ln(a))` |  Transforme une puissance  en une exponentielle |
| Rewrite |  Exp et Ln - exp2trig  | `exp2trig(exp(i*x))` | `from sympy import exp2trig`<br>`i= symbols('i', integer=True)`<br>`exp2trig(exp(i*x))` | `cos(x)+(i)*sin(x)` |  Réécrit une exponentielle complexe  en sinus et cosinus |
| Rewrite |  Exp et Ln - expexpand  |  `expexpand(exp(x+y))` | `from sympy import expexpand`<br>`i= symbols('i', integer=True)`<br>`expexpand(exp(x+y))` | `exp(x)*exp(y)` |  Développe une expression  exponentielle |
| Integer | Diviseurs | `idivis(12)` | `from sympy import divisors`<br>`divisors(12)` | `[1, 2, 3, 4, 6, 12]` | Renvoie la liste des diviseurs d'un entier |
| Integer | Facteurs | `ifactor(20!)` | `from sympy import factorint`<br>`factorint(20)` | `{2: 18, 3: 8, 5: 4, 7: 2, 11: 1, 13: 1, 17: 1, 19: 1}` | Décompose un entier en facteurs premiers |
| Integer | Liste de facteurs | `ifactors(45)` | `from sympy import factors`<br>`factors(45)` | `(3^2 * 5^1)` | Renvoie la liste des facteurs premiers d'un entier avec leur multiplicité |
| Integer | PGCD | `gcd(24,36)` | `from sympy import gcd`<br>`gcd(24, 36)` | `12 `| Calcule le plus grand commun diviseur |
| Integer | PPCM | `lcm(4,6)` | `from sympy import lcm`<br>`lcm(4, 6)` | `12` | Détant l'plus petit commun multiple |
| Integer | Nombre premiers - Tester si nombre premier  | `isPrime(17)` | `from sympy import isprime`<br>`isprime(17)` | `True` | Teste si un nombre est premier |
| Integer | Nombre premiers - Nième nombre premier  | `ithprime(5)` | `from sympy import primerange`<br>`[p for p in primerange(1, 20) if p == ithprime(5)]` | `11` | Renvoie le n-ième nombre premier |
| Integer | Nombre premiers - nombre premier suivant  | `nextprime(11)` | `from sympy import nextprime`<br>`nextprime(11)` | `13` | Détant le prochain nombre premier après un nombre donné |
| Integer | Nombre premiers - nombre premier précédent  | `prevprime(10)` | `from sympy import prevprime`<br>`prevprime(10)` | `7` | Renvoie le nombre premier juste avant un nombre donné |
| Integer | Nombre premiers - Euler  | `euler(10)` | `from sympy import totient`<br>`totient(10)` | `4` | Calcule la fonction totiente d'Euler |
| Polynomial | Racines |  `roots(x²-4)` | `sp.solve(sp.Eq(sp.symbols('x')**2 - 4), sp.symbols('x'))` | `{-2,2}` | Trouve les racines d'un polynôme |
| Polynomial | Coefficients | `coeff(x^3-5x^2+8x-4,2)` | `(sp.symbols('x')**3 - 5*sp.symbols('x')**2 + 8*sp.symbols('x') - 4).as_expr().coeff(sp.symbols('x'), 2)` | `-5` | Renvoie le coefficient du polynôme de degré spécifié |
| Polynomial | Diviseurs | `divis(x^2-1)` | `sp.factor(sp.symbols('x')**2 - 1)` | `[1,x-1,x+1,(x-1)*(x+1)]` | Renvoie la liste des diviseurs d'un polynôme |
| Polynomial | Liste de facteurs | `factors(x^4-2*x^2+1)` | `(sp.symbols('x')**4 - 2*sp.symbols('x')**2 + 1).factor()` | `[x-1,2,x+1,2]` | Donne la liste des facteurs d'un polynôme avec leur multiplicité |
| Polynomial | PGCD | `gcd(x^2+2*x+1,x^2-1)` | `sp.gcd(sp.symbols('x')**2 + 2*sp.symbols('x') + 1, sp.symbols('x')**2 - 1)` | `x+1` | Renvoie le plus grand diviseur commun de deux polynômes |
| Polynomial | PPCM | `lcm(x^2+2*x+1,x^2-1)` | `sp.lcm(sp.symbols('x')**2 + 2*sp.symbols('x') + 1, sp.symbols('x')**2 - 1)` | `(x+1)*(x^2-1)` | Renvoie le plus petit multiple commun de deux polynômes |
| Polynomial | Polynomial Roots wizard | `roots(x²-4)` | `sp.nroots(sp.symbols('x')**2 - 4)` | `-2, 2` | Trouve les racines numériques d'un polynôme |
| Polynomial | Créer - Poly.$\rightarrow$Coef | `symb2poly(x^3-5x^2+8x-4)` | `(sp.symbols('x')**3 - 5*sp.symbols('x')**2 + 8*sp.symbols('x') - 4).as_expr().coeffs()` | `[ -4, 8, -5, 1]` | Convertit un polynôme en une liste de coefficients |
| Polynomial | Créer - Coef.$\rightarrow$Poly | `poly2symb([ -4, 8, -5, 1])` | `sp.poly(sp.symbols('x'), *(-4 + 8*sp.symbols('x') - 5*sp.symbols('x')**2 + sp.symbols('x')**3))` | `x^3 - 5x^2 + 8x - 4` | Convertit une liste de coefficients en un polynôme |
| Polynomial | Créer - Racines$\rightarrow$Coef. | `pcoef([1, -1])` | `sp.poly(sp.symbols('x'), *(1*sp.symbols('x') - 1)*(1*sp.symbols('x') + 1))` | `(x-1)(x+1)` | Construit un polynôme à partir de ses racines |
| Polynomial | Créer - Coef.$\rightarrow$Racines | `fcoeff([1,2,3])` | `sp.symbols('x')**2 + 2*sp.symbols('x') + 3` | `x^2 + 2x + 3` | Construit un polynôme à partir de ses coefficients |
| Polynomial | Créer - Aléatoire | `randint(1,5)` | `[sp.randint(1,5) for _ in range(4)]` | [1,2,3,4] | Génère une liste aléatoire de coefficients pour un polynôme |
| Polynomial | Créer - Minimum | `minimal_polynomial([1,2,3])` | `sp.minpoly(sp.symbols('x'), [1,2,3])` | `x^3 - 6x^2 + 11x - 6` | Calcule le polynôme minimal associé à une liste de coefficients |
| Polynomial | Algèbre - Quotient | `quo(x^3-1,x^2-1)` | `from sympy import symbols, quo`<br>`x = symbols('x')`<br>`quotient = quo(x**3 - 1, x**2 - 1)` | `(x + 1)` | Renvoie le quotient de la division euclidienne de deux polynômes |
| Polynomial | Algèbre - Reste | `rem(x^3-1,x^2-1)` | `from sympy import symbols, rem`<br>`x = symbols('x')`<br>`reste = rem(x**3 - 1, x**2 - 1)` | `(x + 1)` | Renvoie le reste de la division euclidienne de deux polynômes |
| Polynomial | Algèbre - Degré | `degree(x^3+x)` | `from sympy import symbols, degree`<br>`x = symbols('x')`<br>`deg = degree(x**3 + x)` | `3` | Renvoie le degré d'un polynôme |
| Polynomial | Algèbre - Facteur par degré | `factor_xn(x^4-1)` | `from sympy import symbols, factor`<br>`x = symbols('x')`<br>`polynomial = x**4 - 1`<br>`factored_form = polynomial / (x**degree(polynomial)) * x**degree(polynomial)` | `(x + 1)*(x - 1)` | Met en facteur xn dans un polynôme, où n est son degré |
| Polynomial | Algèbre - PGCD coef. | `content(2*x^2+10*x+6)` | `from sympy import symbols, content`<br>`x = symbols('x')`<br>`polynomial = 2*x**2 + 10*x + 6`<br>`gcd_coef = content(polynomial)` | `2` | Renvoie le PGCD des coefficients d'un polynôme |
| Polynomial | Algèbre -Nombre de zéros | `sturmab(x^2*(x^3+2),x,-2,0)` | `from sympy import symbols, sturmab`<br>`x = symbols('x')`<br>`polynomial = x**2 * (x**3 + 2)`<br>`zeros_count = sturmab(polynomial, x, -2, 0)` | `1` | Renvoie le nombre de changements de signe d'un polynôme dans un intervalle |
| Polynomial | Algèbre - Reste chinois | `chinrem([x+2,x^2+1],[x+1,x^2+x+1])` | `from sympy import symbols, chinrem`<br>`x = symbols('x')`<br>`poly_list1 = [x + 2, x**2 + 1]`<br>`poly_list2 = [x + 1, x**2 + x + 1]`<br>`result = chinrem(poly_list1, poly_list2)` | `[-(x**3) - x**2 + 1, x**4 + x**3 + 2*x**2 + x + 1]` | Calcule le reste chinois de deux polynômes |
| Special |  Cyclotomique  | `cyclotomic(5)` | `from sympy.specialpolys import cyclotomic `<br>` x = symbols('x'); print(cyclotomic(5, x))` |`x^4+x^3+x^2+x+1` | Renvoie le polynôme cyclotomique d'ordre n |
| Special |  Base de Gröbner  | `gbasis([x^2+y^2-4,x*y-1],[x,y])` | `from sympy.groebner import groebner_basis`<br>`x, y = symbols('x y'); polynomials = [x**2 + y**2 - 4, x*y - 1]; print(groebner_basis(polynomials, order=x**2 + y))` | `[y^4-4*y^2+1, x+y^3-4*y]` | Calcule une base de Gröbner d'un ensemble de polynômes |
| Special |  Reste de Gröbner  | `greduce(x^2*y,[x^2+y^2-4,x*y-1],[x,y])` | `from sympy.groebner import groebner_reduce`<br>`x, y = symbols('x y'); poly = x**2 * y; basis = [x**2 + y**2 - 4, x*y - 1]; print(groebner_reduce(poly, basis))` |`-y^3+4*y`  | Réduit un polynôme par rapport à une base de Gröbner |
| Special |  Hermite  | `hermite(4,x)` | `from sympy.specialpolys import hermite`<br>`x = symbols('x'); print(hermite(3, x))` | `16*x^4-48*x^2+12` |  Renvoie le polynôme de Hermite de degré n |
| Special |  Lagrange  | `lagrange(,,x)` | `from sympy import interpolate`<br>`x_vals = [0, 1, 2]; f_vals = [0, 1, 2]; poly = interpolate(x_vals, f_vals); print(poly)` | `(x-1)/2` | Calcule le polynôme d'interpolation de Lagrange |
| Special |  Laguerre  | `laguerre(3,x)` | `from sympy.specialpolys import laguerre`<br>`x = symbols('x'); print(laguerre(3, x))` | `1/6*x^3-3/2*x^2+3*x-1` | Renvoie le polynôme de Laguerre de degré n |
| Special |  Legendre  | `legendre(3,x)` | `from sympy.specialpolys import legendre`<br>`x = symbols('x'); print(legendre(3, x))` |`5/2*x^3-3/2*x` | Renvoie le polynôme de Legendre de degré n |
| Special |  $T_n$Tchebyshev  | `tchebyshev1(4,x)` | `from sympy.polynomials.orthopolys import chebyshev_T`<br>` x = symbols('x'); print(chebyshev_T(4, x))` |`8*x^4-8*x^2+1` | Renvoie le polynôme de Tchebychev de première espèce de degré n |
| Special |  $U_n$Tchebyshev  | `tchebyshev2(4,x)` | `from sympy.polynomials.orthopolys import chebyshev_U`<br>` x = symbols('x'); print(chebyshev_U(3, x))` |`16*x^4-12*x^2+1`  | Renvoie le polynôme de Tchebychev de seconde espèce de degré n |
| Plot |  Fonction  | `plotfunc(x^2,x)` | `from sympy import plot`<br>`plot(x**2)` | _Graphique_ | Représente graphiquement une fonction y=f(x) |
| Plot |  Paramétrique  | `plotparam(cos(t)+i*sin(t),t=0..2*pi)` | `from sympy import ParametricPlot, cos, sin`<br>`ParametricPlot(cos(t), sin(t), (t, 0, 2*π))` | _Cercle_ | Trace une courbe paramétrée x=f(t) et y=g(t) |
| Plot |  Polaire  | `plotpolar(cos(3*x),x,0,2*pi)` | `from sympy import polar_plot, cos`<br>`polar_plot(cos(3*x))` | _Trèfle_ | Trace une courbe polaire r=f(θ) |
| Plot |  Suite  | `plotseq(1-x/2, x={3,-1,6}, 5)` | `from sympy import plot_sequence`<br>`plot_sequence(1 - x/2, x=[3, -1, 6])` | _Graphique_ | Trace une suite récurrente |
| Plot |  Graphique Avancés  | N/A | N/A | Permet de définir et d'étudier les graphiques de propositions ouvertes symboliques en x et/ou y. |
| Plot |  Champ de direction  | `plotfield(x*sin(y), [x=-6..6, y=-6..6], normalize)` | `from sympy import plot_vector_field`<br>`plot_vector_field(x*sin(y))` | _Graphique_ | Trace le champ de direction d'une équation différentielle |
| Plot |  EDO  | `plotode(x*sin(y), [x,y], [-2,2])` | `from sympy import plot_ode`<br>`plot_ode(x*sin(y))` | _Graphique_ | Trace la solution d'une équation différentielle |
| Plot |  Contour  | `plotcontour(x^2+2*y^2-2, {x, y}, {2, 4, 6})` | `from sympy import contour_plot`<br>`contour_plot(x**2 + 2*y**2 - 2)` | _Graphique_ | Trace les lignes de niveau d'une fonction de deux variables |


## Menu Math

| Menu | Fonction | Exemple | Code Python | Résultat | Description |
|------|----------|---------|-------------|----------|-------------|
| Nombres |  Plafond  | `CEILING(3.2)` | `import math`<br>`math.ceil(x)`| `4` |  Renvoie le plus petit entier supérieur ou égal à l'argument |
| Nombres |  Plancher  | `FLOOR(3.7)` |`import math`<br>`math.floor(x)` |`3` |  Renvoie le plus grand entier inférieur ou égal à l'argument |
| Nombres |  Partie entière  | `IP(3.7)` | |`3` |  Renvoie la partie entière d'un nombre |
| Nombres |  Partie Fractionnaire  | `FP(3.7)` | |`0.7` | Renvoie la partie fractionnaire d'un nombre |
| Nombres |  Arrondir  | `ROUND(3.14159, 2)` | `import math`<br>`math.round(x)`|`3.14` | Arrondit un nombre réel ou complexe avec n décimales |
| Nombres |  Tronquer  | `TRUNCATE(3.14159, 2)` | `def TRUNCATE(x):`<br>`    return int(x) if x >= 0 else -int(-x)`|`3.14` |  Tronque un nombre réel ou complexe avec n décimales |
| Nombres |  Mantisse  | `MANT(1234)` | `def MANT(x):`<br>`    s = str(x)`<br>`    if '.' in s:`<br>`        integer_part, fractional_part = s.split('.')`<br>`        integer_part += '.' + fractional_part`<br>`    else:`<br>`        integer_part = s + '.'`<br>`        fractional_part = '0'`<br>`    mantissa = float(integer_part[0] + '.' + integer_part[1:])`<br>`    return mantissa` |`1.234` | Renvoie la mantisse d'un nombre réel |
| Nombres |  Exposant  | `XPON(1234)` | `def XPON(x):`<br>`    if x == 0:`<br>`        return 0`<br>`    parts = str(x).split('.')`<br>`    if len(parts) == 1:`<br>`        exponent = len(parts[0]) - 1`<br>`    else:`<br>`        exponent = len(parts[0])`<br>`    return exponent - 1`|`3` |  Renvoie la partie entière du logarithme à base 10 d'un réel |
| Arithmétique |  Maximum  | `MAX(4, 5, 8, 2, 6)` | `from math import max`<br>`max(4, 5, 8, 2, 6)`| `8` | Renvoie le maximum de plusieurs valeurs |
| Arithmétique |  Minimum  | `MIN(4, 5, 8, 2, 6)` | `from math import min`<br>`min(4, 5, 8, 2, 6)` | `2` | Renvoie le minimum de plusieurs valeurs |
| Arithmétique |  Module  | `MOD(17, 5)` | `17 % 5` | `2` | Renvoie le reste de la division euclidienne |
| Arithmétique |  Rechercher la racine  | `FNROOT(x^2-2,x,1)` | `from scipy.optimize import root`<br>`def fnroot(f, x):`<br>` return root(f, x).x[0]` | `1.41421356237` | Recherche une racine d'une expression |
| Arithmétique |  Pourcentage  | `%(20, 50)` | `(20 / 100) * 50` | `10` | Calcule x pourcent de y, soit (x/100)*y |
| Arithmétique |  Complexe - Argument  | N/A | None | N/A |  La source ne précise pas de commande spécifique pour l'argument d'un nombre complexe. |
| Arithmétique |  Complexe - conjuguer  | `CONJ(3+4i)` | `(3 + 4j).conjugate()` | `3-4i` | Renvoie le conjugué d'un nombre complexe |
| Arithmétique |  Complexe - Partie Réelle  | `RE(3+4i)` | `(3 + 4j).real` |`3` | Renvoie la partie réelle d'un nombre complexe |
| Arithmétique |  Complexe - Partie Imaginaire  | `IM(3+4i)` | `(3 + 4j).imag` | `4` | Renvoie la partie imaginaire d'un nombre complexe |
| Arithmétique |  Complexe - Vecteur d'unité  | `SIGN(3+4i)` | `(3 + 4j) / abs(3 + 4j)` | `(3/5)+4/5*i` | Renvoie le signe d'un nombre complexe |
| Arithmétique |  Exponentiel - ALOG  | `ALOG(2)` | `import math`<br>`x = 2`<br>`result = 10 ** x`<br>`print(result)` | `100` | Renvoie 10^x (antilogarithme) |
| Arithmétique |  Exponentiel - EXPM1  | `EXPM1(2)` | `import math`<br>`x = 2`<br>`result = math.exp(x) - 1`<br>`print(result)` | `6.38905609893` | Renvoie exp(x)-1 |
| Arithmétique |  Exponentiel - LNP1  | `LNP1(2)` | `import math`<br>`x = 2`<br>`result = math.log(x + 1)`<br>`print(result)` | `1.09861228867` | Renvoie ln(x+1) |
| Trigonométrie |  CSC  | `CSC(pi/6)` | `import math`<br>`x = math.pi / 6`<br>`result = 1 / math.sin(x)`<br>`print(result)` | `2` | Cosécante : 1/sin(x) |
| Trigonométrie |  ACSC  | `ACSC(2)` | `import math`<br>`x = 2`<br>`result = math.asin(1 / x)`<br>`print(result)` | `pi/6` | Arc-cosécante : csc⁻¹(x) |
| Trigonométrie |  SEC  | `SEC(pi/3)` | `import math`<br>`x = math.pi / 3`<br>`result = 1 / math.cos(x)`<br>`print(result)` | `2` | Sécante : 1/cos(x) |
| Trigonométrie |  ASEC  | `ASEC(2)` | `import math`<br>`x = 2`<br>`result = math.acos(1 / x)`<br>`print(result)` | `pi/3` | Arc-sécante : sec⁻¹(x) |
| Trigonométrie |  COT  | `COT(pi/4)` | `import math`<br>`x = math.pi / 4`<br>`result = math.cos(x) / math.sin(x)`<br>`print(result)` | `1` | Cotangente : cos(x)/sin(x) |
| Trigonométrie |  ACOT  | `ACOT(1)` | `import math`<br>`x = 1`<br>`result = math.atan(1 / x)`<br>`print(result)` | `pi/4` | Arc-cotangente : cot⁻¹(x) |
| Hyperbolique | SINH     | `SINH(1)` | `import math`<br>`x = 1`<br>`print(math.sinh(x))`                                      | `1.17520119364`                  | Sinus hyperbolique : (exp(x) - exp(-x))/2     |
| Hyperbolique | ASINH    | `ASINH(1)` | `import math`<br>`x = 1`<br>`print(math.asinh(x))`                                    | `0.88137358702`                 | Sinus hyperbolique inverse : sinh⁻¹(x)        |
| Hyperbolique | COSH     | `COSH(1)` | `import math`<br>`x = 1`<br>`print(math.cosh(x))`                                      | `1.54308063482`                  | Cosinus hyperbolique : (exp(x) + exp(-x))/2    |
| Hyperbolique | ACOSH    | `ACOSH(2)` | `import math`<br>`x = 2`<br>`print(math.acosh(x))`                                    | `1.31695789692`                 | Cosinus hyperbolique inverse : cosh⁻¹(x)       |
| Hyperbolique | TANH     | `TANH(1)` | `import math`<br>`x = 1`<br>`print(math.tanh(x))`                                      | `0.76159415595`                  | Tangente hyperbolique : sinh(x)/cosh(x)        |
| Hyperbolique | ATANH    | `ATANH(0.5)` | `import math`<br>`x = 0.5`<br>`print(math.atanh(x))`                                 | `0.54930614433`                 | Tangente hyperbolique inverse : tanh⁻¹(x)       |
| Probabilité | Factorielle | `5!` | `from math import factorial`<br>`factorial(5)` | 120 | Factorielle d'un entier positif n. Pour les non-entiers, x! = Γ(x + 1). |
| Probabilité | Combinaison | `COMB(5, 2)` | `from math import comb`<br>`comb(5, 2)` | 10 | Nombre de combinaisons de n objets pris r à la fois. |
| Probabilité | Permutation | `PERM(5, 2)` | `from math import perm`<br>`perm(5, 2)` | 20 |Nombre de permutations de n objets pris r à la fois. |
| Probabilité | Prob.Wizard... | N/A | N/A | N/A | La source ne donne pas d'information sur cette fonction. |
| Probabilité | Aléatoire - Nombre | `RANDOM(2,5)` | `import random`<br>`random.uniform(2, 5)` | _Nombre aléatoire entre 2 et 5_ | Nombre aléatoire. Sans argument, renvoie un nombre entre 0 et 1. Avec un argument a, entre 0 et a. Avec deux arguments a et b, entre a et b. |
| Probabilité | Aléatoire - Nombre entier | `RANDINT(2,5)` | `import random`<br>`random.randint(2, 5)` | _Nombre entier aléatoire entre 2 et 5_ |Nombre entier aléatoire. Sans argument, renvoie 0 ou 1. Avec un argument entier a, entre 0 et a. Avec deux arguments a et b, entre a et b. |
| Probabilité | Aléatoire - Normal | `RANDNORM(0,1)` | `import numpy as np`<br>`np.random.normal(0, 1)` | _Nombre aléatoire selon loi normale_ | Génère un nombre aléatoire à partir d'une distribution normale. |
| Probabilité | Aléatoire - Val.initiale | `RANDSEED(1)` | `import random`<br>`random.seed(1)` | N/A |Initialise la séquence de nombres aléatoires. |
| Probabilité |  Densité - Normal  | `NORMALD(0, 1, 0.5)` | `from scipy.stats import norm`<br>`norm.pdf(x, loc=μ, scale=σ)` |`0.352065326764` | Calcule la densité de probabilité de la loi normale en x, avec moyenne μ et écart-type σ. Si un seul argument est donné, il est considéré comme x avec μ=0 et σ=1.|
| Probabilité |  Densité - T  | `STUDENT(3, 5.2)` | `from scipy.stats import t`<br>`t.pdf(x, df=n)` |`0.00366574413491` | Calcule la densité de probabilité de la loi de Student en x, avec n degrés de liberté.|
| Probabilité |  Densité - χ²  | `CHISQUARE(2, 3.2)` | `from scipy.stats import chi2`<br>`chi2.pdf(x, df=k)` |`0.100948258997` | Calcule la densité de probabilité de la loi du χ² en x, avec n degrés de liberté.|
| Probabilité |  Densité - F  | `FISHER(4, 10, 2.1)` | `from scipy.stats import f`<br>`f.pdf(x, df1=m, df2=n)` |0.141167840452` | Calcule la densité de probabilité de la loi de Fisher en x, avec n et d degrés de liberté.|
| Probabilité |  Densité - Binomiale  | `BINOMIAL(4, 2, 0.5)` | `import math`<br>`math.comb(n, k) * p**k * (1-p)**(n-k)` |`0.375` | Calcule la probabilité de k succès en n tentatives, avec probabilité de succès p. Si seul n et k sont donnés, renvoie `COMB(n,k)`. |
| Probabilité |  Densité - Géométrique  | `GEOMETRIC(0.3, 4)` | `import math`<br>`(1-p)**(x-1) * p` |`0.1029` | Calcule la densité de probabilité de la loi géométrique en x avec la probabilité p.|
| Probabilité |  Densité - Poisson  | `POISSON(0.5, 2)` | `import math`<br>`math.exp(-μ) * μ**k / math.factorial(k)` |`0.0758163324641` | Calcule la probabilité de k occurrences d'un événement, avec moyenne μ d'occurrences. |
| Probabilité |  Inverse - Normal  | `NORMALD_ICDF(0, 1, 0.95)` | `from scipy.stats import norm`<br>`x = norm.ppf(p, loc=mean, scale=std)` | `1.64485362695` | Calcule la valeur x pour laquelle la probabilité inférieure de la loi normale est p, avec moyenne μ et écart-type σ. Si un seul argument est donné, il est considéré comme p avec μ=0 et σ=1. |
| Probabilité |  Inverse - T  | `STUDENT_ICDF(5, 0.95)` | `from scipy.stats import t`<br>`x = t.ppf(p, df)` | `2.01504837333` | Calcule la valeur x pour laquelle la probabilité inférieure de la loi de Student est p, avec n degrés de liberté. |
| Probabilité |  Inverse - χ²  | `CHISQUARE_ICDF(5, 0.95)` | `from scipy.stats import chi2`<br>`x = chi2.ppf(p, df)` | `11.0704976935` | Calcule la valeur x pour laquelle la probabilité inférieure de la loi du χ² est p, avec n degrés de liberté. |
| Probabilité |  Inverse - F  | `FISHER_ICDF(5, 3, 0.95)` | `from scipy.stats import f`<br>`x = f.ppf(p, df1, df2)` | `9.01345516752` | Calcule la valeur x pour laquelle la probabilité inférieure de la loi de Fisher est p, avec n et d degrés de liberté.|
| Probabilité |  Inverse - Binomiale  | `BINOMIAL_ICDF(4, 0.5, 0.9)` | `from scipy.stats import binom`<br>`x = binom.ppf(q, n, p)` | `3` | Calcule le nombre de succès k pour lequel la probabilité d'avoir k succès ou moins est q, en n tentatives, avec probabilité de succès p. |
| Probabilité |  Inverse - Géométrique  | `GEOMETRIC_ICDF(0.3, 0.95)` | `from scipy.stats import geom`<br>`x = geom.ppf(q, p) + 1` | `9` | Calcule la valeur x pour laquelle la probabilité inférieure de la loi géométrique est k, avec probabilité p. |
| Probabilité |  Inverse - Poisson  | `POISSON_ICDF(10.0, 0.975)` | `from scipy.stats import poisson`<br>`x = poisson.ppf(q, mu)` | `16` | Calcule la valeur x pour laquelle la probabilité d'avoir x occurrences ou moins est p, avec moyenne μ d'occurrences. |
| Liste |  Créer une liste  | `MAKELIST(X^2+1,X,2,6)` | `[x**2 + 1 for x in range(2,7)]` | `{5,10,17,26,37}` | Crée une liste en évaluant une expression pour chaque valeur d'une variable dans un intervalle donné. L'incrément peut être omis.|
| Liste |  Trier  | `SORT({2,5,3})` | `[sorted_list] = sorted([2, 5, 3])` | `{2,3,5}` | Trie les éléments d'une liste par ordre croissant. |
| Liste |  Inverser  | `REVERSE({1,2,3})` | `[reversed_list] = [x[::-1]] or list(reversed(original_list))` | `{3,2,1}` | Crée une nouvelle liste avec les éléments de la liste d'origine dans l'ordre inverse. |
| Liste |  Concaténer  | `CONCAT({1,2,3},{4})`| `[new_list] = list1 + list2`  | `{1,2,3,4}` | Concatène deux listes en une seule. |
| Liste |  Position  | `POS({3,7,12,19},12)` | `[index] = list.index(element) if element in list else 0` | `3` | Renvoie la position de la première occurrence d'un élément dans une liste. Retourne 0 si l'élément n'est pas trouvé. |
| Liste |  Taille  | `SIZE({1,2,3})`  | `[size] = len(list)`  | `3` | Renvoie le nombre d'éléments dans une liste. |
| Liste |  Liste Δ  | `ΔLIST({3,5,8,12,17,23})` | `[diffs] = [list[i+1] - list[i] for i in range(len(list)-1)]`  | `{2,3,4,5,6}` | Crée une liste avec les différences entre les éléments consécutifs de la liste d'origine. |
| Liste |  Liste Σ  | `ΣLIST({1,2,3,4,5})`  | `[total] = sum(list)` | `15` | Renvoie la somme de tous les éléments d'une liste. |
| Liste |  Liste Π  | `ΠLIST({1,2,3,4,5})` | `[product] = math.prod(list) if using Python 3.8+ else functools.reduce(lambda x,y: x*y, list)` | `120` | Renvoie le produit de tous les éléments d'une liste. |
| Liste |  Union  | Non disponible | None | Non disponible | Il n'y a pas de fonction "Union" dans les menus listes des sources.
| Liste |  Différence  | `DIFFERENCE({1,2,3,4}, {1,3,5,7})` | `from sets import Set`<br>`even = [x for x in list1 if x % 2 == 0]`<br>`print(even)`<br>`list(set(list1) - set(list2)) + list(set(list2) - set(list1))` | `{2,4,5,7}` |  Renvoie une liste qui contient tous les éléments de la première liste qui ne sont pas présents dans la deuxième, ainsi que tous les éléments de la deuxième liste qui ne sont pas présents dans la première.|
| Liste |  Intersection  | `INTERSECT({1,2,3,4}, {1,3,5,7})` | `from sets import Set`<br>`even = [x for x in list1 if x % 2 == 0]`<br>`print(even)`<br>`list(set(list1).intersection(set(list2)))` | `{1,3}` |  Renvoie une liste contenant les éléments communs aux deux listes. |
| Liste |  EQ  | Non disponible | Non disponible | None | TODO: Voir manuel |
| Matrice     | Transposer      | `TRN([,])`             | `import numpy as np`<br>`def transpose(matrix):`<br>` return np.array(matrix).T`<br>`matrix = [[1, 2], [3, 4]]`<br>`transposed_matrix = transpose(matrix)`  | `[[],]`  | Transpose une matrice. Pour une matrice complexe, la fonction `TRN` trouve le transposé conjugué.   |
| Matrice     | Déterminant      | `DET([,])`  | `def determinant(matrix):`<br>` return np.linalg.det(np.array(matrix))`<br>`matrix = [[a, b], [c, d]]`<br>`det = determinant(matrix)`    | `-2`   | Calcule le déterminant d'une matrice carrée.    |
| Matrice     | RREF            | `RREF([[1,1,-1,5],[2,-1,0,7],[1,-2,1,2]])` | `def rref(matrix):`<br>` return np.array(matrix).rref()[0]`<br>`matrix = [[1,1,-1,5],[2,-1,0,7],[1,-2,1,2]]`<br>`rref_matrix = rref(matrix)`   | `[[1,0,-1/3,4],[0,1,-2/3,1],]` | Modifie une matrice rectangulaire pour obtenir sa forme échelonnée réduite.   |
| Matrice     | Créer - Créer    | `MAKEMAT(I*J,2,3)`      | `def create_matrix(expression, rows, cols):`<br>` return [[expression(i, j) for j in range(cols)] for i in range(rows)]`<br>`def expression(i, j):`<br>` return i + j`<br>`matrix = create_matrix(expression, 2, 3)`    | `[,]`                     | Crée une matrice en utilisant une expression pour calculer chaque élément en fonction de ses indices de ligne (I) et de colonne (J).    |
| Matrice     | Créer - Identité | `IDENMAT(3)`     | `def identity_matrix(n):`<br>` return [[1 if i == j else 0 for j in range(n)] for i in range(n)]`<br>`matrix = identity_matrix(3)` | `[,,]`  | Crée une matrice identité carrée de la taille spécifiée.     |
| Matrice |  Créer - Aléatoire  | `RANDMAT(M1,2,2)` | `import numpy as np`<br>`def RANDMAT(m, n=None, low=-99, high=99):`<br>`    if n is None:`<br>`        n = m`<br>`    return np.random.randint(low, high+1, (m, n))`| `[[,],[,]]`  | Crée une matrice de nombres entiers aléatoires entre -99 et 99, avec les dimensions spécifiées. Peut aussi créer un vecteur aléatoire si un seul entier est donné. Les bornes de l'intervalle peuvent être changées en donnant une paire d'entiers supplémentaire. En mode CAS, `ranm(n,p)` crée une matrice aléatoire de n lignes et p colonnes avec des nombres entiers entre -99 et 99.|
| Matrice |  Créer - Jordan  | `JordanBlock(7,3)` | `def JordanBlock(a, n):`<br>`    return np.diag([a]*n) + np.diag([1]*(n-1), 1)`| `[,,]`  | Crée une matrice carrée avec la valeur donnée sur la diagonale, 1 au-dessus de la diagonale et 0 ailleurs. En mode HOME, cette fonction doit être utilisée avec la syntaxe `CAS.JordanBlock(a,n)`.|
| Matrice |  Créer - Hilbert  | `hilbert(3)` | `def hilbert(n):`<br>`    return np.array([[1/(i+j-1) for j in range(1, n+1)] for i in range(1, n+1)])`| `[[1,1/2,1/3],[1/2,1/3,1/4],[1/3,1/4,1/5]]` | Crée la matrice de Hilbert d'ordre n, où chaque élément est défini par la formule 1/(j+k-1), j étant le numéro de ligne et k le numéro de colonne. En mode HOME, cette fonction doit être utilisée avec la syntaxe `CAS.hilbert(n)`. |
| Matrice |  Créer - Isométrique  | `mkisom(,1)` | `def mkisom(vector, sign):`<br>`    n = len(vector)`<br>`    I = np.eye(n)`<br>`    return I * sign`| `[[,]]` | Crée une matrice d'isométrie à partir d'un vecteur et d'un signe (+1 pour direct, -1 pour indirect). En mode HOME, cette fonction doit être utilisée avec la syntaxe `CAS.mkisom(vecteur, signe)`. En dimension 3, le vecteur est le vecteur directeur de l’axe et l’angle de la rotation ou le vecteur de la normale au plan de symétrie.|
| Matrice |  Créer - Vandermonde  | `vandermonde()` | `def vandermonde(vector):`<br>`  n = len(vector)`<br>`  return np.array([[x**(i) for i in range(n)] for x in vector])` | `[,,]`  | Crée la matrice de Vandermonde à partir d'un vecteur donné. Chaque ligne de la matrice est formée des puissances successives des éléments du vecteur. |
| Matrice |  Basique - Norme  | `|[,]|` | `import numpy as np`<br>`def FROBNORM(matrix):`<br>`    return np.linalg.norm(matrix)`| `5.47722557505` | Calcule la norme de Frobenius d'une matrice, qui est la racine carrée de la somme des carrés des éléments de la matrice. La fonction `ABS()` avec une matrice comme argument, renvoie également la norme de Frobenius. |
| Matrice |  Basique - Norme de ligne  | `ROWNORM([[1,-2,3],[4,5,-6]])` |`import numpy as np`<br>`def ROWNORM(matrix):`<br>`    return np.max(np.sum(abs(matrix), axis=1))` | `15`  | Calcule la norme de ligne d'une matrice, qui est la valeur maximale des sommes des valeurs absolues des éléments de chaque ligne. En mode CAS, `rownorm(matrice)` donne le même résultat.|
| Matrice |  Basique - Norme de colonne  | `COLNORM([[1,-2,3],[4,5,-6]])` | `import numpy as np`<br>`def COLNORM(matrix):`<br>`    return np.max(np.sum(abs(matrix), axis=0))`| `9` | Calcule la norme de colonne d'une matrice, qui est la valeur maximale des sommes des valeurs absolues des éléments de chaque colonne. En mode CAS, `colnorm(matrice)` donne le même résultat. |
| Matrice |  Basique - Norme Spectrale  | `SPECNORM([,])` |  `import numpy as np`<br>`def SPECNORM(matrix):`<br>`    return np.linalg.norm(matrix, ord=2)`| `2.41421356237` | Calcule la norme spectrale d'une matrice carrée, qui est la plus grande valeur singulière de la matrice. En mode HOME, cette fonction doit être utilisée avec la syntaxe `CAS.SPECNORM(matrice)`. |
| Matrice |  Basique - Rayon spectral  | `SPECRAD([,])` |  `import numpy as np`<br>`def SPECRAD(matrix):`<br>`    eigenvalues = np.linalg.eigvals(matrix)`<br>`    return max(abs(eigenvalues))`| `5.37228132327` | Calcule le rayon spectral d'une matrice carrée, qui est le maximum des valeurs absolues des valeurs propres de la matrice. |
| Matrice |  Basique - Condition  | `COND([,])` | `import numpy as np`<br>` matrix = np.array([[1, 2], [3, 4]])`<br>` condition_number = np.linalg.cond(matrix, norm='inf')`<br>` print(condition_number)`<br><br>**Résultat :** `condition_number` contient le numéro de condition. | `22` | Calcule le numéro de condition d'une matrice carrée, en utilisant la norme 1 (norme de colonne) de la matrice et de son inverse. |
| Matrice |  Basique - Rang  | `RANK([,])` | `import numpy as np`<br>` matrix = np.array([[1, 2], [3, 4]])`<br>` rank = np.linalg.matrix_rank(matrix)`<br>` print(rank)`<br><br>**Résultat :** `rank` contient le rang de la matrice. | `2` | Calcule le rang d'une matrice rectangulaire, qui est le nombre maximum de colonnes linéairement indépendantes. En mode CAS, `rank(matrice)` donne le même résultat. |
| Matrice |  Basique - Pivot  | `pivot([,,],2,2)` | `import numpy as np`<br>` matrix = np.array([[1, 0, 0], [0, 2, 3], [0, 4, 5]])`<br>` pivot_row = 1`<br>` pivot_col = 1`<br>` matrix[pivot_row:] = matrix[pivot_row:, pivot_col:] / matrix[pivot_row, pivot_col]`<br><br>**Résultat :** `matrix` est modifiée pour avoir des zéros dans la colonne spécifiée, sauf à la position du pivot. | `[,,]` | Utilise l'élimination de Gauss pour mettre des zéros dans la colonne spécifiée, sauf à la position du pivot. |
| Matrice |  Basique - Tracer  | `TRACE([,])` | `import numpy as np`<br>` matrix = np.array([[1, 2], [3, 4]])`<br>` trace = np.trace(matrix)`<br>` print(trace)`<br><br>**Résultat :** `trace` contient la somme des éléments diagonaux. | `5` | Calcule la trace d'une matrice carrée, qui est la somme de ses éléments diagonaux. |
| Matrice |  Avancé - Valeurs Propres  | `EIGENVAL([,])` | `import numpy as np`<br>` matrix = np.array([[1, 2], [3, 4]])`<br>` eigenvalues = np.linalg.eigvals(matrix)`<br>` print(eigenvalues)`<br><br>**Résultat :** `eigenvalues` contient les valeurs propres de la matrice. | `[5.37228132327,-0.37228132327]`  | Affiche les valeurs propres d'une matrice sous forme de vecteur. En mode CAS, `eigenvals(matrice)` donne le même résultat. |
| Matrice |  Avancé - Vecteur Propres  | `EIGENVV([,])` | `from numpy import linalg as np_lg`<br>`import numpy as np`<br>`A = np.array([[3, -1], [-1, 2]])`<br>`values, vectors = np_lg.eig(A)`<br>`print("Vecteurs propres:\n", vectors)`<br>`print("Valeurs propres:", values)`| `[[0.4159735623,0.909376711],[0.909376711,-0.4159735623]], [5.37228132327,-0.37228132327]`  | Affiche une liste de deux matrices : la première contient les vecteurs propres, et la deuxième les valeurs propres d'une matrice carrée. En mode CAS, `eigenvects(matrice)` renvoie la matrice des vecteurs propres d'une matrice diagonalisable. |
| Matrice |  Avancé - Jordan  | `jordan([,,])` |  `from sympy import Matrix `<br>` `<br>`A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`<br>`B = Matrix(A)`<br>`P, J = B.jordan_form(matrix=True, indices=True)`<br>`print("Matrice de passage P:\n", P)`<br>`print("Forme de Jordan J:\n", J)`| `[[3,-1,1],[2,-1,0],],[,,]` | Renvoie une liste formée de la matrice de passage et de la forme de Jordan d'une matrice.. En mode HOME, cette fonction doit être utilisée avec la syntaxe `CAS.jordan(matrice)` pour un résultat exact. |
| Matrice |  Avancé - Diagonale  | `diag()` |  `import numpy as np `<br>`# Créer une matrice diagonale à partir d'un vecteur `<br>` `<br>`diagonal_matrix = np.diag([1, 2, 3])`<br>`print("Matrice diagonale:\n", diagonal_matrix) `<br>`# Extraire les éléments diagonaux d'une matrice `<br>` `<br>`A = np.array([[4, 5], [6, 7]])`<br>`diag_elements = np.diag(A)`<br>`print("Éléments diagonaux:", diag_elements)`| `[,]` | Crée une matrice diagonale à partir d'un vecteur donné, ou renvoie un vecteur des éléments diagonaux d'une matrice. En mode HOME, cette fonction doit être utilisée avec la syntaxe `CAS.diag(matrice)`. |
| Matrice |  Avancé - Cholesky  | `cholesky([,])` |  `import numpy as np `<br>` `<br>`A = np.array([[4, 12, 32], [12, 56, 80], [32, 80, 256]])`<br>`L = np.linalg.cholesky(A)`<br>`print("Factorisation de Cholesky L:\n", L)`| `[,]` | Calcule la factorisation de Cholesky d'une matrice symétrique définie positive. |
| Matrice |  Avancé - Hermite  | `ihermite([,,])` |  `from sympy import Matrix `<br>` `<br>`A = [[1, 2], [3, 4]]`<br>`B = Matrix(A)`<br>`H = B.hermite_form()`<br>`print("Forme d'Hermite:\n", H)`| `[[1,0,-1],,]` |  Calcule la forme normale de Hermite d'une matrice. |
| Matrice |  Avancé - Hessenberg  | `hessenberg([,,],3)` | `import scipy.linalg as sp`<br>`sp.hess([[1,2,3],[4,5,6],[7,8,9]]) # Renvoie B` | `[[,,],[[1,-1,0],[1,-1,0],]]` | Réduit une matrice à la forme de Hessenberg. Renvoie la matrice de passage P et la matrice B semblable à A dont les coefficients sous-sous-diagonaux sont nuls, tel que B = P⁻¹AP ou B ∼ P⁻¹AP. En mode HOME, cette fonction doit être utilisée avec la syntaxe `CAS.hessenberg(matrice)`. |
| Matrice |  Avancé - Smith  | `ismith([,])` | `import sympy as sy`<br>`sy.Matrix([[1,2],[3,4]]).smitify() # Renvoie U, B, V` | `[,[2,-1]],[,],[[1,-2],]]` | Calcule la forme normale de Smith d'une matrice A à coefficients entiers. Renvoie les matrices U, B, V avec U et V inversibles dans Z, B diagonale, B[i,i] divise B[i+1,i+1], et B = U*A*V. En mode HOME, cette fonction doit être utilisée avec la syntaxe `CAS.ismith(matrice)`. |
| Matrice |  Factoriser - LQ  | `LQ([,])` | `import scipy.linalg as sp`<br>`sp.lstb([[1,2],[3,4]]) # Renvoie L, Q, P` | `[[[2.2360679775,0.],[4.9193495505,0.894427191]], [[0.4472135955,0.894427191],[0.894427191,-0.4472135955]], [,]]` | Factorise une matrice m × n en trois matrices L, Q et P, où L est une matrice triangulaire inférieure m × n, Q est une matrice orthogonale n × n et P une matrice de permutation m × m, et P _A = L_ Q. |
| Matrice |  Factoriser - LSQ  | `LSQ([,],[[5,-1],[11,-1]])` | `import numpy as np`<br>`np.linalg.lstsq([[1,2],[3,4]], [[5,-1],[11,-1]], rcond=None) # Renvoie x, residuals, rank, singular_values` | `[,[2,-1]]` | Affiche la matrice (ou le vecteur) des moindres carrés de la norme minimale correspondant au système matrice1*X=matrice2.|
| Matrice |  Factoriser - LU  | `LU([,])` | `import scipy.linalg as sp`<br>`sp.lu([[1,2],[3,4]]) # Renvoie P, L, U` | `[[[0.333333333333,1]], [,[0,0.666666666667]], [,]]` | Factorise une matrice carrée en trois matrices : L (triangulaire inférieure), U (triangulaire supérieure) et P (permutation), telles que P*A = L*U. |
| Matrice |  Factoriser - QR  | `QR([,],var1,var2)` | `import numpy as np`<br>`Q, R = np.linalg.qr(A)` | `([[1.0,0.0], [0.0,1.0]], [[3.16227766017,4.427188724], [0.0,0.632455532034]]`| Factorise une matrice A m × n en mode numérique sous la forme Q*R, où Q est une matrice orthogonale et R est une matrice triangulaire supérieure, et renvoie R.  R est stocké dans var2 et Q=A*inv(R) est stocké dans var1.|
| Matrice |  Factoriser - SCHUR  | `SCHUR([,,[-1,3,-2]])` | `from scipy.linalg import schur`<br>`Qz, Sz = schur(A, 'real')` |`[ [ [ -0.196116135138, -0.788607839052, -0.577350269189 ], [ -0.872871560944, 0.158781035639, 0.467739737705 ], [ -0.447213595499, 0.596237139605, -0.669507242923 ] ], [ [ 6.18777613969, 1.4326683314, -0.597889271725 ], [ 0, -2.25199708457, 4.23989552958 ], [ 0, 0, -0.935779055121 ] ] ]` | Factorise une matrice carrée en deux matrices. Si la matrice est réelle, le résultat est {[[orthogonale]],[[quasi-triangulaire supérieure]]}. Si la matrice est complexe, le résultat est {[[unitaire]],[[triangulaire supérieure]]}. |
| Matrice |  Factoriser - SVD  | `SVD([,])` |  `from numpy.linalg import svd`<br>`U, S, V = svd(A)`|`[[-0.404553584834,-0.914514295677],[-0.914514295677,0.404553584834]], [5.46498570422,0.365966190626], [[-0.576048436767,0.81741556047],[-0.81741556047,-0.576048436766]]` | Factorise une matrice m × n en deux matrices et un vecteur. {[[m × m orthogonale carrée]],[[n × n orthogonale carrée]], [réel]}.  |
| Matrice |  Factoriser - SVL  | `SVL([,])` | `from numpy.linalg import svd`<br>`_, S, _ = svd(A)` |`[4.30277563773,0.697224362268]` | Renvoie un vecteur contenant les valeurs singulières de la matrice. |
| Matrice |  Vecteur - Produit croisé  | `CROSS(,)` | `import numpy as np`<br>`np.cross(a, b)` |`` | Calcule le produit vectoriel de deux vecteurs. |
| Matrice |  Vecteur - Produit scalaire  | `dot(,)` | `import numpy as np`<br>`np.dot(a, b)` | `11` | Calcule le produit scalaire de deux vecteurs. |
| Matrice |  Vecteur - Norme L²  | `l2norm()` | `import numpy as np`<br>`np.linalg.norm(vector)` |`5` | Calcule la norme L² (ou euclidienne) d'un vecteur, qui est la racine carrée de la somme des carrés de ses composantes.  |
| Matrice |  Vecteur - Norme L¹  | `l1norm()` |  `import numpy as np`<br>`np.linalg.norm(vector, ord=1)` |`7` | Calcule la norme L¹ d'un vecteur, qui est la somme des valeurs absolues de ses composantes.  |
| Matrice |  Vecteur - Norme Max.  | `maxnorm()` | `import numpy as np`<br>`np.linalg.norm(vector, ord=np.inf)` |`4` | Calcule la norme maximale d'un vecteur, qui est la plus grande valeur absolue de ses composantes. |
| Spécial | Beta | `Beta(2,3)` | `import scipy.special as sp`<br>`sp.beta(2, 3)` | `1/12` | Calcule la fonction Beta d'Euler pour deux arguments. |
| Spécial | Gamma | `Gamma(5)` | `import scipy.special as sp`<br>`sp.gamma(5)` | `24` | Calcule la fonction Gamma d'Euler pour un argument. |
| Spécial | Psi | `Psi(1)` | `import scipy.special as sp`<br>`sp.digamma(1)` | `-0.577215664902` | Calcule les dérivées de la fonction Digamma. |
| Spécial | Zeta | `Zeta(2)` | `import scipy.special as sp`<br>`sp.zeta(2)` | `1.64493406685` | Calcule la fonction Zeta de Riemann pour un argument. |
| Spécial |  erf  | `erf(1)` | `from scipy.special import erf` <br> `result = erf(1)` |`0.84270079295` | Calcule la fonction d'erreur erf. |
| Spécial |  erfc  | `erfc(1)` | `from scipy.special import erfc` <br> `result = erfc(1)` |`0.15729920704` | Calcule la fonction d'erreur complémentaire erfc. |
| Spécial |  Ei    | `Ei(1)`    | `from scipy.special import euler_gamma` <br> `result = euler_gamma(1)` |`1.89511781636` |  Calcule la fonction exponentielle intégrale d'une expression. Cette fonction est définie comme l'intégrale de -∞ à x de e^t/t dt.  |
| Spécial |  Si    | `Si(pi/2)` | `from scipy.special import si` <br> `import math` <br> `result = si(math.pi/2)` |`1.37076214447` | Calcule la fonction sinus intégral pour un nombre complexe a. Cette fonction est définie par l'intégrale de 0 à x de sin(t)/t dt. |
| Spécial |  Ci    | `Ci(pi)`  | `from scipy.special import ci` <br> `import math` <br> `result = ci(math.pi)` |`0.18700380454`    | Calcule la fonction cosinus intégral pour un nombre complexe a. Cette fonction est définie par l'intégrale de γ + ln(x) + l'intégrale de 0 à x de (cos(t)-1)/t dt, où γ est la constante d'Euler. |



